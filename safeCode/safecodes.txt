// С помощью вычисления subIndexVector и прибавлении к нему степов можно вычислить выходим ли мы за рамки ноды

// =) вроде теперь норм
    const ivec3 node_pos = currentNode.position.xyz;
    const int halfSize = currentNode.halfSize;
    const int nodeSize = halfSize * 2;

    if (rayDirection.x < 0) {
       rayLength.x = (start_position.x - float(node_pos.x - halfSize)) * rayStepSize.x;
    } else {
       rayLength.x = (float(node_pos.x + halfSize) - start_position.x) * rayStepSize.x;
    }

    if (rayDirection.y < 0) {
       rayLength.y = (start_position.y - float(node_pos.y - halfSize)) * rayStepSize.y;
    } else {
       rayLength.y = (float(node_pos.y + halfSize) - start_position.y) * rayStepSize.y;
    }

    if (rayDirection.z < 0) {
       rayLength.z = (start_position.z - float(node_pos.z - halfSize)) * rayStepSize.z;
    } else {
       rayLength.z = (float(node_pos.z + halfSize) - start_position.z) * rayStepSize.z;
    }

// VERY FAST DDA
    rayLength = (step * (voxelPos - start_position) + (step * 0.5f) + 0.5f) * rayStepSize;

    bvec3 mask;
    int iter = 0;
    while(iter++ < 200) {
        mask = lessThanEqual(rayLength.xyz, min(rayLength.yzx, rayLength.zxy));
        rayLength += vec3(mask) * rayStepSize;
        voxelPos += ivec3(vec3(mask)) * step;
    }