#version 430

precision highp float;

layout(local_size_x = 1, local_size_y = 1) in;

struct Node {
    ivec4 position;
    vec4 color;
    int halfSize;
    int sub;
};

layout(std430, binding=4) readonly buffer Octree_data {
    Node nodes[];
};

struct HitPoint {
    float distance;
    bool hit;
    vec3 color;
};

layout(rgba32f) uniform image2D img_output;

layout(location=2) uniform vec3 start_position;

layout(location=3) uniform vec2 camera_angles;

layout(location=4) uniform vec2 window_size;

int getSubIndex(in ivec3 vec, in ivec4 pos, in int halfSize) {
    if (vec.x < pos.x) return -1;
    if (vec.y < pos.y) return -2;
    if (vec.z < pos.z) return -3;

    const int size = halfSize * 2;
    if (vec.x > pos.x + size) return -4;
    if (vec.y > pos.y + size) return -5;
    if (vec.z > pos.z + size) return -6;

    int subIndex = 0;
    subIndex |= vec.x >= pos.x + halfSize? 2 : 0;
    subIndex |= vec.y >= pos.y + halfSize? 4 : 0;
    subIndex |= vec.z >= pos.z + halfSize? 1 : 0;

    return subIndex;
}

bool nodeIsLeaf(in Node node) {
    return node.color.a != -1.0f;
}

bool findVoxel(in ivec3 voxelPos, inout HitPoint result) {
    int index = 0;
    while(index != -1) {
        const Node currentNode = nodes[index];
        if (currentNode.sub == -1) {
            if (nodeIsLeaf(currentNode)) {
                result.hit = true;
                result.color = currentNode.color.rgb;
                return true;
            }
            return true;
        }

        const int subIndex = getSubIndex(voxelPos, currentNode.position, currentNode.halfSize);
        if (subIndex < 0) return false;

        index = currentNode.sub + subIndex;
    }
    return false;
}

void castRay(in vec3 rayDirection, in float maxDistance, out HitPoint result) {
    result.hit = false;

    // ВЫЧИСЛЯЕТСЯ РАССТОЯНИЕ ДО СЛЕДУЮЩЕГО ПЕРЕСЕЧЕНИЯ ПО ОСИ ЕСЛИ 0.1 = 
    // угол по X то 1 / 0.1 = 10 значит через расстояние = 10 луч пересечётся с осью Y
    const vec3 rayStepSize = abs(1.0f / rayDirection);

    vec3 rayLenght;
    ivec3 voxelPos = ivec3(start_position);
    ivec3 step = ivec3(sign(rayDirection));

    int nodeSize = nodes[0].halfSize * 2;

    if (rayDirection.x < 0) {
        rayLenght.x = (start_position.x - float(voxelPos.x)) * rayStepSize.x;
    } else {
        rayLenght.x = (float(voxelPos.x + 1) - start_position.x) * rayStepSize.x;
    }

    if (rayDirection.y < 0) {
        rayLenght.y = (start_position.y - float(voxelPos.y)) * rayStepSize.y;
    } else {
        rayLenght.y = (float(voxelPos.y + 1) - start_position.y) * rayStepSize.y;
    }

    if (rayDirection.z < 0) {
        rayLenght.z = (start_position.z - float(voxelPos.z)) * rayStepSize.z;
    } else {
        rayLenght.z = (float(voxelPos.z + 1) - start_position.z) * rayStepSize.z;
    }

    while(result.distance < maxDistance) {
        if (rayLenght.x < rayLenght.y) {
            if (rayLenght.x < rayLenght.z) {
                voxelPos.x += step.x;
                result.distance = rayLenght.x;
                rayLenght.x += rayStepSize.x;
            } else {
                voxelPos.z += step.z;
                result.distance = rayLenght.z;
                rayLenght.z += rayStepSize.z;
            }
        } else {
            if (rayLenght.y < rayLenght.z) {
                voxelPos.y += step.y;
                result.distance = rayLenght.y;
                rayLenght.y += rayStepSize.y;
            } else {
                voxelPos.z += step.z;
                result.distance = rayLenght.z;
                rayLenght.z += rayStepSize.z;
            }
        }

        if (!findVoxel(voxelPos, result)) {
            break;
        }

        if (result.hit) {
            break;
        }
    }
}

void main() {
    const ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.xy);
    const vec2 screen_offset = vec2(window_size.x / 2.0, window_size.y / 2.0);
    const vec3 camera_origin = vec3(0, 0, -window_size.x);
    const vec3 screen_coord = vec3(pixel_coord - screen_offset, 0.0);

    // Ray calculation
    const float sinX = sin(-camera_angles.x);
    const float cosX = cos(-camera_angles.x);
    const float sinY = sin(camera_angles.y);
    const float cosY = cos(camera_angles.y);

    vec3 ray = normalize(screen_coord - camera_origin);
    ray = vec3(ray.x,                         ray.y * cosY - ray.z * sinY,   ray.y * sinY + ray.z * cosY);
    ray = vec3(ray.x * cosX - ray.z * sinX,   ray.y,                         ray.x * sinX + ray.z * cosX);

    const float maxDist = 500.0f;

    HitPoint result;
    castRay(ray, maxDist, result);

    imageStore(img_output, pixel_coord, vec4(result.color, 1.0));
}

// DEBUG TOOL
//        if (voxelPos.x == 1 && voxelPos.y == 0 && voxelPos.z == 0) {
//            result.hit = true;
//            result.color.r = 1.0f;
//        } else if (voxelPos.x == 0 && voxelPos.y == 1 && voxelPos.z == 0) {
//            result.hit = true;
//            result.color.g = 1.0f;
//        } else if (voxelPos.x == 0 && voxelPos.y == 0 && voxelPos.z == 1) {
//            result.hit = true;
//            result.color.b = 1.0f;
//        }