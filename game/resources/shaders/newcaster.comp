#version 430

precision highp float;

layout(local_size_x = 1, local_size_y = 1) in;

struct Node {
    ivec4 position;
    vec4 color;
    int halfSize;
    int sub;
};

uniform Check {
    vec4 position;
};

layout(std430, binding=4) readonly buffer Octree_data {
    Node nodes[];
};

struct HitPoint {
    float distance;
    bool hit;
    vec3 color;
};

layout(rgba32f) uniform image2D img_output;

layout(location=2) uniform vec3 start_position;

layout(location=3) uniform vec2 camera_angles;

layout(location=4) uniform vec2 window_size;

int getSubIndex(in ivec3 vec, in ivec4 pos, in int halfSize) {
    int subIndex = 0;

    if (vec.x < pos.x) return -1;
    if (vec.y < pos.y) return -2;
    if (vec.z < pos.z) return -3;

    const int size = halfSize * 2;
    if (vec.x > pos.x + size) return -4;
    if (vec.y > pos.y + size) return -5;
    if (vec.z > pos.z + size) return -6;

    subIndex |= vec.x >= pos.x + halfSize? 2 : 0;
    subIndex |= vec.y >= pos.y + halfSize? 4 : 0;
    subIndex |= vec.z >= pos.z + halfSize? 1 : 0;

    return subIndex;
}

void findVoxel(in ivec3 voxelPos, inout HitPoint result) {
    int index = 0;
    int iter = 0;
    while(index != -1) {
        const Node currentNode = nodes[index];
        if (currentNode.sub == -1) {
            if (currentNode.color.a != -1.0f) {
                result.hit = true;
                result.color = currentNode.color.rgb;
                return;
            }
            return;
        }

        const int subIndex = getSubIndex(voxelPos, currentNode.position, currentNode.halfSize);
        if (subIndex < 0) return;

        index = currentNode.sub + subIndex;
        iter++;
    }
}

void castRay(in vec3 rayDirection, in float maxDistance, out HitPoint result) {
    result.hit = false;

    const int worldSize = nodes[0].halfSize * 2;
    const int powWorldSize = worldSize * worldSize;

    const vec3 rayStepSize = abs(1.0f / rayDirection);
    vec3 rayLenght;
    ivec3 voxelPos = ivec3(start_position);
    ivec3 step;

    if (rayDirection.x < 0) {
        step.x = -1;
        rayLenght.x = (start_position.x - float(voxelPos.x)) * rayStepSize.x;
    } else {
        step.x = 1;
        rayLenght.x = (float(voxelPos.x + 1) - start_position.x) * rayStepSize.x;
    }

    if (rayDirection.y < 0) {
        step.y = -1;
        rayLenght.y = (start_position.y - float(voxelPos.y)) * rayStepSize.y;
    } else {
        step.y = 1;
        rayLenght.y = (float(voxelPos.y + 1) - start_position.y) * rayStepSize.y;
    }

    if (rayDirection.z < 0) {
        step.z = -1;
        rayLenght.z = (start_position.z - float(voxelPos.z)) * rayStepSize.z;
    } else {
        step.z = 1;
        rayLenght.z = (float(voxelPos.z + 1) - start_position.z) * rayStepSize.z;
    }

    while(result.distance < maxDistance) {
        if (rayLenght.x < rayLenght.y) {
            if (rayLenght.x < rayLenght.z) {
                voxelPos.x += step.x;
                result.distance = rayLenght.x;
                rayLenght.x += rayStepSize.x;
            } else {
                voxelPos.z += step.z;
                result.distance = rayLenght.z;
                rayLenght.z += rayStepSize.z;
            }
        } else {
            if (rayLenght.y < rayLenght.z) {
                voxelPos.y += step.y;
                result.distance = rayLenght.y;
                rayLenght.y += rayStepSize.y;
            } else {
                voxelPos.z += step.z;
                result.distance = rayLenght.z;
                rayLenght.z += rayStepSize.z;
            }
        }

        findVoxel(voxelPos, result);
//        if (voxelPos.x == 1 && voxelPos.y == 0 && voxelPos.z == 0) {
//            result.hit = true;
//            result.color.r = 1.0f;
//        } else if (voxelPos.x == 0 && voxelPos.y == 1 && voxelPos.z == 0) {
//            result.hit = true;
//            result.color.g = 1.0f;
//        } else if (voxelPos.x == 0 && voxelPos.y == 0 && voxelPos.z == 1) {
//            result.hit = true;
//            result.color.b = 1.0f;
//        }

        if (result.hit) {
            break;
        }
    }
}


void main() {
    const ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.xy);
    const vec2 screen_offset = vec2(window_size.x / 2.0, window_size.y / 2.0);
    const vec3 camera_origin = vec3(0, 0, -window_size.x);
    const vec3 screen_coord = vec3(pixel_coord - screen_offset, 0.0);

    // Ray calculation
    const float sinX = sin(-camera_angles.x);
    const float cosX = cos(-camera_angles.x);
    const float sinY = sin(camera_angles.y);
    const float cosY = cos(camera_angles.y);

    vec3 ray = normalize(screen_coord - camera_origin);
    ray = vec3(ray.x,                         ray.y * cosY - ray.z * sinY,   ray.y * sinY + ray.z * cosY);
    ray = vec3(ray.x * cosX - ray.z * sinX,   ray.y,                         ray.x * sinX + ray.z * cosX);

    const float maxDist = 500.0f;

    HitPoint result;
    castRay(ray, maxDist, result);

    vec3 pixel = vec3(0, 0, 0);
    if (result.hit) {
        pixel = result.color;
    }

    imageStore(img_output, pixel_coord, vec4(pixel, 1.0));
}


//    int halfS = nodes[1].halfSize;
//   bool leaf = nodes[1].leaf;
////    int leaf = nodes[0].leaf;
//    //if (leaf == 22) {
//    //if (nodes.length() == 1)
//        //pixel.r = 1.0f;
//    //}
////    if (nodes[0].color.y != 0) {
////        pixel.r = 1.0f;
////    }
//    if (leaf) {
//        pixel.r = 1.0f;
//    }
//if (halfS == 2) {
//    pixel.r = 1.0f;
//}
//
//
//    if (poss == 1.0f) {
//        pixel.g = 1.0f;
//    }
//    if (poss.y > 1) {
//        pixel.g = 1.0f;
//    }
//    if (poss.z > 1) {
//        pixel.b = 1.0f;
//    }