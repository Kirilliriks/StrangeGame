#version 430

precision highp float;

layout(local_size_x = 2, local_size_y = 2) in;

struct Color {
    float r;
    float g;
    float b;
};

layout(std430, binding=4) readonly buffer Octree_data {
    Color voxels[];
};

layout(rgba32f) uniform image2D img_output;

layout(location=2) uniform vec3 start_position;

layout(location=3) uniform vec2 camera_angles;

layout(location=4) uniform vec2 window_size;

struct HitPoint {
    float distance;
    bool hit;
    vec3 color;
};

void castRay(in vec3 rayDirection, in float maxDistance, out HitPoint result) {
    result.hit = false;

    const vec3 rayStepSize = abs(1.0f / rayDirection);
    ivec3 mapCheck = ivec3(start_position);
    vec3 rayLenght;
    ivec3 step;

    if (rayDirection.x < 0) {
        step.x = -1;
        rayLenght.x = (start_position.x - float(mapCheck.x)) * rayStepSize.x;
    } else {
        step.x = 1;
        rayLenght.x = (float(mapCheck.x + 1) - start_position.x) * rayStepSize.x;
    }

    if (rayDirection.y < 0) {
        step.y = -1;
        rayLenght.y = (start_position.y - float(mapCheck.y)) * rayStepSize.y;
    } else {
        step.y = 1;
        rayLenght.y = (float(mapCheck.y + 1) - start_position.y) * rayStepSize.y;
    }

    if (rayDirection.z < 0) {
        step.z = -1;
        rayLenght.z = (start_position.z - float(mapCheck.z)) * rayStepSize.z;
    } else {
        step.z = 1;
        rayLenght.z = (float(mapCheck.z + 1) - start_position.z) * rayStepSize.z;
    }

    while(result.distance < maxDistance) {
        if (rayLenght.x < rayLenght.y) {
            if (rayLenght.x < rayLenght.z) {
                mapCheck.x += step.x;
                result.distance = rayLenght.x;
                rayLenght.x += rayStepSize.x;
            } else {
                mapCheck.z += step.z;
                result.distance = rayLenght.z;
                rayLenght.z += rayStepSize.z;
            }
        } else {
            if (rayLenght.y < rayLenght.z) {
                mapCheck.y += step.y;
                result.distance = rayLenght.y;
                rayLenght.y += rayStepSize.y;
            } else {
                mapCheck.z += step.z;
                result.distance = rayLenght.z;
                rayLenght.z += rayStepSize.z;
            }
        }

        if (mapCheck.x >= 0 && mapCheck.x < 400 && mapCheck.y >= 0 && mapCheck.y < 400 && mapCheck.z >= 0 && mapCheck.z < 400) {
            const Color col = voxels[mapCheck.x + mapCheck.y * 400 + mapCheck.z * 160000];
            if (col.b != 0) {
                result.hit = true;
                result.color = vec3(col.r, col.g, col.b);
                break;
            }
        } else {
            break;
        }
    }
}


void main() {
    const ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.xy);
    const vec2 screen_offset = vec2(window_size.x / 2.0, window_size.y / 2.0);
    const vec3 camera_origin = vec3(0, 0, -window_size.x);
    const vec3 screen_coord = vec3(pixel_coord - screen_offset, 0.0);

    // Ray calculation
    const float sinX = sin(-camera_angles.x);
    const float cosX = cos(-camera_angles.x);
    const float sinY = sin(camera_angles.y);
    const float cosY = cos(camera_angles.y);

    vec3 ray = normalize(screen_coord - camera_origin);
    ray = vec3(ray.x,                         ray.y * cosY - ray.z * sinY,   ray.y * sinY + ray.z * cosY);
    ray = vec3(ray.x * cosX - ray.z * sinX,   ray.y,                         ray.x * sinX + ray.z * cosX);

    const float maxDist = 500.0f;

    HitPoint result;
    castRay(ray, maxDist, result);

    vec3 pixel = vec3(0, 0, 0);
    if (result.hit) {
        pixel = result.color - result.distance / maxDist;
    }
    imageStore(img_output, pixel_coord, vec4(pixel, 1.0));
}