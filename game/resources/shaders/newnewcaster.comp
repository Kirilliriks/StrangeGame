#version 430

precision highp float;

layout(local_size_x = 1, local_size_y = 1) in;

struct Node {
    ivec4 position;
    vec4 color;
    int halfSize;
    int sub;
};

layout(std430, binding=4) readonly buffer Octree_data {
    Node nodes[];
};

struct HitPoint {
    float distance;
    bool hit;
    vec3 color;

    bool debug;
    ivec3 debugPos;
};

layout(rgba32f) uniform image2D img_output;

layout(location=2) uniform vec3 start_position;

layout(location=3) uniform vec2 camera_angles;

layout(location=4) uniform vec2 window_size;

layout(location=5) uniform ivec3 debug_pos_cast;

layout(location=6) uniform ivec3 debug_node_pos;

layout(location=7) uniform int debug_node_size;

layout(location=8) uniform ivec3 debug_init_pos;

layout(location=9) uniform ivec3 debug_next_node_pos;

layout(location=10) uniform ivec3 observer_pos;

bool nodeIsLeaf(in Node node) {
    return node.color.a != -1.0f;
}

ivec3 getSubVector(in ivec3 vec, in Node node) {
    ivec3 subVector = ivec3(0, 0, 0);

    const ivec3 pos = node.position.xyz;
    if (vec.x < pos.x) return ivec3(-1, -1, -1);
    if (vec.y < pos.y) return ivec3(-1, -1, -1);
    if (vec.z < pos.z) return ivec3(-1, -1, -1);

    const int halfSize = node.halfSize;
    const int size = halfSize * 2;
    if (vec.x > pos.x + size) return ivec3(-1, -1, -1);
    if (vec.y > pos.y + size) return ivec3(-1, -1, -1);
    if (vec.z > pos.z + size) return ivec3(-1, -1, -1);

    subVector.x = vec.x >= pos.x + halfSize? 1 : 0;
    subVector.y = vec.y >= pos.y + halfSize? 1 : 0;
    subVector.z = vec.z >= pos.z + halfSize? 1 : 0;

    return subVector;
}

int getSubIndex(in ivec3 vec, in Node node) {
    int subIndex = 0;

    const ivec3 pos = node.position.xyz;
    if (vec.x < pos.x) return -1;
    if (vec.y < pos.y) return -2;
    if (vec.z < pos.z) return -3;

    const int halfSize = node.halfSize;
    const int size = halfSize * 2;
    if (vec.x > pos.x + size) return -4;
    if (vec.y > pos.y + size) return -5;
    if (vec.z > pos.z + size) return -6;

    subIndex |= vec.x >= pos.x + halfSize? 2 : 0;
    subIndex |= vec.y >= pos.y + halfSize? 4 : 0;
    subIndex |= vec.z >= pos.z + halfSize? 1 : 0;

    return subIndex;
}

bool findVoxel(in ivec3 voxelPos, inout HitPoint result) {
    int index = 0;
    while(index != -1) {
        const Node currentNode = nodes[index];
        if (currentNode.sub == -1) {
            if (nodeIsLeaf(currentNode)) {
                result.hit = true;
                result.color = currentNode.color.rgb;
                return true;
            }
            return true;
        }

        const int subIndex = getSubIndex(voxelPos, currentNode);
        if (subIndex < 0) return false;

        index = currentNode.sub + subIndex;
    }
    return false;
}

struct Layer {
    int nodeIndex;
    vec3 step;
    ivec3 subVector;
};

void calculate_rayLength(in Node currentNode, in vec3 start_position, in vec3 rayDirection, in vec3 rayStepSize, inout vec3 rayLength, inout HitPoint result) {
    const ivec3 node_pos = currentNode.position.xyz;
    const int halfSize = currentNode.halfSize;

    if (rayDirection.x < 0) {
        rayLength.x = (start_position.x - float(node_pos.x - halfSize)) * rayStepSize.x;
    } else {
        rayLength.x = (float(node_pos.x + halfSize) - start_position.x) * rayStepSize.x;
    }

    if (rayDirection.y < 0) {
        rayLength.y = (start_position.y - float(node_pos.y - halfSize)) * rayStepSize.y;
    } else {
        rayLength.y = (float(node_pos.y + halfSize) - start_position.y) * rayStepSize.y;
    }

    if (rayDirection.z < 0) {
        rayLength.z = (start_position.z - float(node_pos.z - halfSize)) * rayStepSize.z;
    } else {
        rayLength.z = (float(node_pos.z + halfSize) - start_position.z) * rayStepSize.z;
    }

    if (rayLength.x < rayLength.y) {
        if (rayLength.x < rayLength.z) {
            result.distance = rayLength.x;
        } else {
            result.distance = rayLength.z;
        }
    } else {
        if (rayLength.y < rayLength.z) {
            result.distance = rayLength.y;
        } else {
            result.distance = rayLength.z;
        }
    }
}

bool move_next(in Layer layer, in ivec3 step, inout vec3 rayLength, inout HitPoint result) {
    if (rayLength.x < rayLength.y) {
        if (rayLength.x < rayLength.z) {
            const int tmp = layer.subVector.x + step.x;
            if (tmp > 1 || tmp < 0) return false;

            result.distance = rayLength.x;
            rayLength.x += layer.step.x;
        } else {
            const int tmp = layer.subVector.z + step.z;
            if (tmp > 1 || tmp < 0) return false;

            result.distance = rayLength.z;
            rayLength.z += layer.step.z;
        }
    } else {
        if (rayLength.y < rayLength.z) {
            const int tmp = layer.subVector.y + step.y;
            if (tmp > 1 || tmp < 0) return false;

            result.distance = rayLength.y;
            rayLength.y += layer.step.y;
        } else {
            const int tmp = layer.subVector.z + step.z;
            if (tmp > 1 || tmp < 0) return false;

            result.distance = rayLength.z;
            rayLength.z += layer.step.z;
        }
    }
    return true;
}

void debugCast(in vec3 rayDirection, in float maxDistance, inout HitPoint result) {
    result.hit = false;
    result.distance = 0.0f;

    // ВЫЧИСЛЯЕТСЯ РАССТОЯНИЕ ДО СЛЕДУЮЩЕГО ПЕРЕСЕЧЕНИЯ ПО ОСИ ЕСЛИ 0.1 =
    // угол по X то 1 / 0.1 = 10 значит через расстояние = 10 луч пересечётся с осью Y
    const vec3 rayStepSize = abs(1.0f / rayDirection);

    vec3 rayLenght;
    ivec3 voxelPos = ivec3(start_position);
    ivec3 step = ivec3(sign(rayDirection));
    int nodeSize = nodes[0].halfSize * 2;

    if (rayDirection.x < 0) {
        rayLenght.x = (start_position.x - float(voxelPos.x)) * rayStepSize.x;
    } else {
        rayLenght.x = (float(voxelPos.x + 1) - start_position.x) * rayStepSize.x;
    }

    if (rayDirection.y < 0) {
        rayLenght.y = (start_position.y - float(voxelPos.y)) * rayStepSize.y;
    } else {
        rayLenght.y = (float(voxelPos.y + 1) - start_position.y) * rayStepSize.y;
    }

    if (rayDirection.z < 0) {
        rayLenght.z = (start_position.z - float(voxelPos.z)) * rayStepSize.z;
    } else {
        rayLenght.z = (float(voxelPos.z + 1) - start_position.z) * rayStepSize.z;
    }

    const int maxSize = nodeSize;
    while(result.distance < maxDistance) {
        if (rayLenght.x < rayLenght.y) {
            if (rayLenght.x < rayLenght.z) {
                voxelPos.x += step.x;
                result.distance = rayLenght.x;
                rayLenght.x += rayStepSize.x;
            } else {
                voxelPos.z += step.z;
                result.distance = rayLenght.z;
                rayLenght.z += rayStepSize.z;
            }
        } else {
            if (rayLenght.y < rayLenght.z) {
                voxelPos.y += step.y;
                result.distance = rayLenght.y;
                rayLenght.y += rayStepSize.y;
            } else {
                voxelPos.z += step.z;
                result.distance = rayLenght.z;
                rayLenght.z += rayStepSize.z;
            }
        }

        const ivec3 debug_node_pos_max = ivec3(debug_node_pos.x + debug_node_size - 1, debug_node_pos.y + debug_node_size - 1, debug_node_pos.z + debug_node_size - 1);
        if (voxelPos.x == debug_node_pos.x && voxelPos.y == debug_node_pos.y && voxelPos.z == debug_node_pos.z) { // 0 0 0
            result.hit = true;
            result.color.b = 1.0f;
        } else if (voxelPos.x == debug_node_pos_max.x && voxelPos.y == debug_node_pos.y && voxelPos.z == debug_node_pos.z) { //1 0 0
            result.hit = true;
            result.color.b = 1.0f;
        } else if (voxelPos.x == debug_node_pos_max.x && voxelPos.y == debug_node_pos.y && voxelPos.z == debug_node_pos_max.z) {// 1 0 1
            result.hit = true;
            result.color.b = 1.0f;
        } else if (voxelPos.x == debug_node_pos.x && voxelPos.y == debug_node_pos.y && voxelPos.z == debug_node_pos_max.z) { // 0 0 1
            result.hit = true;
            result.color.b = 1.0f;
        } else if (voxelPos.x == debug_node_pos.x && voxelPos.y == debug_node_pos_max.y && voxelPos.z == debug_node_pos.z) { // 0 1 0
            result.hit = true;
            result.color.b = 1.0f;
        } else if (voxelPos.x == debug_node_pos_max.x && voxelPos.y == debug_node_pos_max.y && voxelPos.z == debug_node_pos.z) { // 1 1 0
            result.hit = true;
            result.color.b = 1.0f;
        } else if (voxelPos.x == debug_node_pos_max.x && voxelPos.y == debug_node_pos_max.y && voxelPos.z == debug_node_pos_max.z) { // 1 1 1
            result.hit = true;
            result.color.b = 1.0f;
        } else if (voxelPos.x == debug_node_pos.x && voxelPos.y == debug_node_pos_max.y && voxelPos.z == debug_node_pos_max.z) { // 0 1 1
            result.hit = true;
            result.color.b = 1.0f;
        }

        if (!result.hit) {
            findVoxel(voxelPos, result);
        }

        if (debug_next_node_pos == voxelPos) {
            result.hit = true;
            result.color.g = 0;
            result.color.b = 1;
            result.color.r = 1;
            return;
        }
        if (debug_init_pos == voxelPos) {
            result.hit = true;
            result.color.g = 1;
            result.color.b = 0;
            result.color.r = 0;
            return;
        }

        if (debug_pos_cast == voxelPos) {
            result.hit = true;
            result.color.g = 0;
            result.color.b = 0;
            result.color.r = 1.0f;
            return;
        }

        if (observer_pos == voxelPos) {
            result.hit = true;
            result.color.g = 1;
            result.color.b = 1;
            result.color.r = 0;
            return;
        }


        if (result.hit) {
            break;
        }
    }
}
// TODO ОБРАТИ ВНИМАНИЕ ДЕБИЛ
// Можно проверить работу шейдера рисуя изначальную ноду по calculate_rayLength!!!
//
// так же подумать как всё таки вычислять voxelPos не используя result.distance

void castRay(in vec3 rayDirection, in float maxDistance, out HitPoint result) {
    result.hit = false;
    result.distance = 0.0f;

    // ВЫЧИСЛЯЕТСЯ РАССТОЯНИЕ ДО СЛЕДУЮЩЕГО ПЕРЕСЕЧЕНИЯ ПО ОСИ ЕСЛИ 0.1 =
    // угол по X то 1 / 0.1 = 10 значит через расстояние = 10 луч пересечётся с осью X
    const int maxDepth = 6; //
    const int maxSize = nodes[0].halfSize * 2;
    const vec3 rayStep = abs(1.0f / rayDirection);
    const ivec3 step = ivec3(sign(rayDirection));

    vec3 rayLength;
    ivec3 voxelPos = ivec3(start_position);

    Layer layers[maxDepth + 1];

    int currentDepth = maxDepth;

    int index = 0;
    Layer currentLayer;
    Node currentNode = nodes[index];
    currentLayer.step = abs(vec3(currentNode.halfSize * 2) / rayDirection);
    currentLayer.nodeIndex = index;
    currentLayer.subVector = getSubVector(voxelPos, currentNode);
    layers[currentDepth] = currentLayer;

    bool first = true;
    int iter = -1;

    while (iter++ < 100.0f) {
        currentNode = nodes[index];
        currentLayer = layers[currentDepth];

        if (currentNode.sub != -1) { // Node have subNodes
            voxelPos = ivec3(start_position + rayDirection * result.distance); // Calculate current voxelPosition

            const int subIndex = getSubIndex(voxelPos, currentNode);
            if (subIndex < 0) return; // EXIT, or maybe check error?

            index = currentNode.sub + subIndex;
            currentDepth--;

            Layer newLayer;
            newLayer.step = abs(vec3(currentNode.halfSize) / rayDirection);
            newLayer.nodeIndex = index;
            newLayer.subVector = getSubVector(voxelPos, currentNode);
            layers[currentDepth] = newLayer;
            continue;
        } else { // Node can be voxel or be empty
            if (nodeIsLeaf(currentNode)) { //Node is voxel
                result.hit = true;
                result.color = currentNode.color.rgb;
                return;
            } else { // Find next node
                if (first) { // If first iter calculate first nearest intersect pos
                    first = false;
                    calculate_rayLength(currentNode, start_position, rayDirection, rayStep, rayLength, result);
                    continue;
                }

                if(move_next(currentLayer, step, rayLength, result)) {
                    continue;
                }

                currentDepth++;
                index = layers[currentDepth].nodeIndex;
            }
        }
    }
}

vec3 rotate(const in vec3 v, const in vec3 axis, float theta) {
    const float cos_theta = cos(theta);
    return (v * cos_theta) + (cross(axis, v) * sin(theta)) + (axis * dot(axis, v)) * (1 - cos_theta);
}

void main() {
    const ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.xy );
    const ivec2 screen_offset = ivec2(window_size.x / 2, window_size.y / 2);
    const vec3 camera_origin = vec3(0, 0, window_size.x);
    const ivec3 screen_coord = ivec3(pixel_coord - screen_offset, 0);

    // Ray calculation
    const float sinX = sin(camera_angles.x);
    const float cosX = cos(camera_angles.x);
    const float sinY = sin(-camera_angles.y);
    const float cosY = cos(-camera_angles.y);

    vec3 rayDir = normalize(screen_coord + camera_origin);
    rayDir = rotate(rayDir, vec3(1, 0, 0), camera_angles.y);
    rayDir = rotate(rayDir, vec3(0, 1, 0), camera_angles.x);
    const float maxDist = 500.0f;

    HitPoint result;
    //castRay(rayDir, maxDist, result);
    debugCast(rayDir, maxDist, result);
    if (!result.hit) {
        result.color = vec3(0, 0, 0);
    }

    imageStore(img_output, pixel_coord, vec4(result.color, 1.0));
}
