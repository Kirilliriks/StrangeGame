#version 460

layout(local_size_x = 1,local_size_y = 1,local_size_z = 1) in;

layout(std430, binding=4) readonly buffer Octree_data {
    vec4 voxels[];
};

layout(rgba32f) uniform image2D img_output;

layout(location=2) uniform vec3 start_position;

layout(location=3) uniform vec2 camera_angles;

layout(location=4) uniform vec2 window_size;

layout(location=5) uniform ivec3 fron_voxel_pos;

layout(location=6) uniform int size;

layout(location=7) uniform int height;

vec4 debugCast(in vec3 rayDirection) {
    const vec3 rayStepSize = abs(1.0f / rayDirection);
    const ivec3 step = ivec3(sign(rayDirection));
    const int zSize = height * size;

    ivec3 voxelPos = ivec3(start_position);
    bvec3 mask;
    vec3 rayLength = (step * (voxelPos - start_position) + (step * 0.5f) + 0.5f) * rayStepSize;
    int iter = 0;
    while(iter++ < 256) {
        mask = lessThanEqual(rayLength.xyz, min(rayLength.yzx, rayLength.zxy));
        rayLength += vec3(mask) * rayStepSize;
        voxelPos += ivec3(vec3(mask)) * step;
        if (voxelPos.x >= size || voxelPos.y >= height || voxelPos.z >= size || voxelPos.x < 0 || voxelPos.y < 0 || voxelPos.z < 0 ) return vec4(0, 0, 0, 0);

        const vec4 color = voxels[voxelPos.x + voxelPos.y * height + voxelPos.z * zSize];
        if (color.a == 1.0f) return color;
    }
    return vec4(0, 0, 0, 0);
}

vec3 rotate(const in vec3 v, const in vec3 axis, float theta) {
    const float cos_theta = cos(theta);
    return (v * cos_theta) + (cross(axis, v) * sin(theta)) + (axis * dot(axis, v)) * (1 - cos_theta);
}

void main() {
    const ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.xy);
    vec3 rayDir = normalize(ivec3(pixel_coord - ivec2(window_size.x / 2, window_size.y / 2), window_size.x));
    rayDir = rotate(rayDir, vec3(1, 0, 0), camera_angles.y);
    rayDir = rotate(rayDir, vec3(0, 1, 0), camera_angles.x);
    imageStore(img_output, pixel_coord, debugCast(rayDir));
}
