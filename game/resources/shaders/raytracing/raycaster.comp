#version 430

#define maxDepth 8
#define octreeSize (1 << maxDepth)
#define octreeHalfSize (octreeSize / 2)

layout(local_size_x = 8, local_size_y = 8) in;

uint localID = gl_LocalInvocationID.x  + gl_LocalInvocationID.y * 8;

struct Node {
    ivec4 position;
    vec4 color;
    int sub;
};

layout(std430, binding=4) readonly buffer Octree_data {
    Node nodes[];
};

layout(std430, binding=5) readonly buffer Octree_matrix {
    int octrees[];
};

layout(rgba32f) uniform image2D img_output;

layout(location=2) uniform vec3 start_position;

layout(location=3) uniform vec2 camera_angles;

layout(location=4) uniform vec2 window_size;

layout(location=5) uniform ivec3 front_voxel;

layout(location=6) uniform ivec3 debug_voxel;

layout(location=7) uniform int octrees_radius;
layout(location=8) uniform int octrees_diameter;
layout(location=9) uniform ivec3 space_center;
layout(location=10) uniform vec4 background_color;

int getSubIndex(const in int halfSize, const in ivec3 vec, const in Node node) {
    const ivec3 pos = node.position.xyz;
    if (vec.x < pos.x || vec.y < pos.y || vec.z < pos.z) return -1;

    const int size = halfSize * 2;
    if (vec.x >= pos.x + size || vec.y >= pos.y + size || vec.z >= pos.z + size) return -1;

    int subIndex = 0;
    subIndex |= vec.x >= pos.x + halfSize ? 2 : 0;
    subIndex |= vec.y >= pos.y + halfSize ? 4 : 0;
    subIndex |= vec.z >= pos.z + halfSize ? 1 : 0;

    return subIndex;
}

bool findVoxel(const in ivec3 voxelPos, out vec3 color) {
    int index = 0;
    float halfSize = octreeHalfSize;
    while (index != -1) {
        const Node currentNode = nodes[index];
        if (currentNode.sub == -1) {
            if (currentNode.color.a != -1.0) {
                color = currentNode.color.rgb;
                return true;
            }
            return false;
        }

        const int subIndex = getSubIndex(int(halfSize), voxelPos, currentNode);
        if (subIndex < 0) return false;

        index = currentNode.sub + subIndex;
        halfSize *= 0.5;
    }
    return false;
}

bool getNode(const int octreeBaseNodeID, const in ivec3 voxelPos, const in int nodeDepth, out Node node) {
    int index = octreeBaseNodeID;
    int depth = 0;
    float halfSize = octreeHalfSize;
    while (index != -1) {
        const Node currentNode = nodes[index];
        if (depth == nodeDepth) {
            node = nodes[index];
            return true;
        }

        const int subIndex = getSubIndex(int(halfSize), voxelPos, currentNode);
        if (subIndex < 0) return false;

        index = octreeBaseNodeID + currentNode.sub + subIndex;
        depth++;
        halfSize *= 0.5;
    }

    return false;
}

vec3 insideCubeHit(
    const in vec3 localRayPosition,
    const in vec3 signedDirection,
    const in vec3 rayStepSizeSingle,
    float size
) {
    size *= 0.5;

    return -(signedDirection * (localRayPosition - size) - size) * rayStepSizeSingle;
}

vec4 castRay(
    const in int octreeBaseNodeID,
    const in vec3 rayDirection,
    const in vec3 rayStartPosition,
    const in vec3 octreePosition
) {
    const vec3 signedDirection = sign(rayDirection);
    const vec3 rayStepSizeSingle = 1.0 / max(abs(rayDirection), 0.001);

    float size = octreeSize;

    vec3 localRayPosition = rayStartPosition - octreePosition;
    vec3 voxelRayPosition = vec3(0);

    vec3 mask;
    bool exitOctree = false;
    int depth = 0;
    float distance = 0.0;

    for (int iterations = 0; iterations < 500 && distance < 1000; iterations++) {

        if (exitOctree) {
            size *= 2.0;
            const vec3 newVoxelRayPosition = floor(voxelRayPosition / size) * size;

            localRayPosition += voxelRayPosition - newVoxelRayPosition;
            voxelRayPosition = newVoxelRayPosition;

            depth--;

            exitOctree = (depth > 0) &&
                abs(
                    dot(
                        mod(voxelRayPosition / size + 0.5, 2.0)
                        - 1.0 + mask * signedDirection * 0.5,
                        mask
                    )
                ) < 0.1;
            continue;
        }

        Node node;
        if (!getNode(octreeBaseNodeID, ivec3(voxelRayPosition), depth, node) || node.color.a > 0) {
//            if (voxelRayPosition == debug_voxel && voxelRayPosition - mask * signedDirection == front_voxel) {
//                return vec4(0, 255, 255, 255);
//            }

            return node.color; // !getNode, alghorithm return color == background_color
        }

        if (node.sub != -1) {
            depth++;
            size *= 0.5;

            const vec3 downMask = step(vec3(size), localRayPosition) * size;
            voxelRayPosition += downMask;
            localRayPosition -= downMask;
        } else {
            const vec3 hit = insideCubeHit(localRayPosition, signedDirection, rayStepSizeSingle, size);

            mask = vec3(lessThan(hit, min(hit.yzx, hit.zxy)));
            const float len = dot(hit, mask);

            distance += len;
            localRayPosition += rayDirection * len - mask * signedDirection * size;

            const vec3 newVoxelRayPosition = voxelRayPosition + mask * signedDirection * size;
            exitOctree = (floor(newVoxelRayPosition / size * 0.5) != floor(voxelRayPosition / size * 0.5));

            voxelRayPosition = newVoxelRayPosition;
        }
    }

    return background_color;
}

int getOctreeBaseNodeId(ivec3 octreePosition) {
    ivec3 relativeOctree = octreePosition;
    if (relativeOctree.x < -octrees_radius || relativeOctree.x > octrees_radius ||
        relativeOctree.y < -octrees_radius || relativeOctree.y > octrees_radius ||
        relativeOctree.z < -octrees_radius || relativeOctree.z > octrees_radius
    ) {
        return -1;
    }

    relativeOctree += octrees_radius;
    return octrees[relativeOctree.x + (relativeOctree.z * octrees_diameter + relativeOctree.y) * octrees_diameter];
}

vec4 castWorld(const in vec3 rayDirection) {
    const ivec3 step = ivec3(sign(rayDirection));

    const vec3 rayStepSizeSingle = 1.0 / max(abs(rayDirection), 0.001);
    const vec3 rayStepSize = rayStepSizeSingle * octreeSize;

    ivec3 octreePosition = ivec3(floor(start_position / octreeSize));

    vec3 rayLength = -(step * (mod(start_position, octreeSize) - octreeHalfSize) - octreeHalfSize) * rayStepSizeSingle;

    vec3 mask;

    float distance = 0.0;
    for (int iterations = 0; iterations < 200; iterations++) {
        const int octreeID = getOctreeBaseNodeId(octreePosition);
        if (octreeID != -1) {
            const vec4 res = castRay(octreeID, rayDirection, start_position + rayDirection * distance, octreePosition * octreeSize);
            if (res.a > 0) {
                return res;
            }
        }

        mask = vec3(lessThanEqual(rayLength.xyz, min(rayLength.yzx, rayLength.zxy)));

        rayLength += mask * rayStepSize;
        distance = length(mask * (rayLength - rayStepSize));
        octreePosition += ivec3(mask) * step;
    }

    return background_color;
}

void rotate(inout vec3 v, const in vec3 axis, const in float theta) {
    const float cos_theta = cos(theta);
    v = (v * cos_theta) + (cross(axis, v) * sin(theta)) + (axis * dot(axis, v)) * (1 - cos_theta);
}

void main() {
    const ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.xy);
    const ivec3 screen_coord = ivec3(pixel_coord - window_size / 2, -window_size.x / 2.0f);

    vec3 rayDir = normalize(screen_coord);
    rotate(rayDir, vec3(1, 0, 0), camera_angles.y);
    rotate(rayDir, vec3(0, 1, 0), camera_angles.x);

    imageStore(img_output, pixel_coord, castWorld(rayDir));
}

/*

vec4 debugCast(const in vec3 rayDirection) {
    vec3 color = vec3(0);

    const vec3 rayStepSize = abs(1.0f / rayDirection);
    const ivec3 step = ivec3(sign(rayDirection));
    ivec3 voxelPos = ivec3(start_position);
    vec3 rayLength = (step * (voxelPos - start_position) + (step * 0.5) + 0.5) * rayStepSize;

    const int maxSize = nodes[0].halfSize * 2;
    bvec3 mask;
    int iter = 0;
    while (iter++ < 700) {
        mask = lessThanEqual(rayLength.xyz, min(rayLength.yzx, rayLength.zxy));
        rayLength += vec3(mask) * rayStepSize;
        voxelPos += ivec3(vec3(mask)) * step;

        if (findVoxel(voxelPos, color)) return vec4(color, 1.0);
    }
    return vec4(color, 1.0);
}

*/