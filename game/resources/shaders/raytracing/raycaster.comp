#version 430

#define maxDepth 8

layout(local_size_x = 8, local_size_y = 8) in;

struct Layer {
    vec3 position;
    int nodeIndex;
    ivec3 subVec;
    vec3 rayLength;
    float distance;
};

struct Batch {
    Layer layers[maxDepth];
};

shared Batch batchs[64];

uint localID = gl_LocalInvocationID.x  + gl_LocalInvocationID.y * 8;

struct Node {
    ivec4 position;
    vec4 color;
    int halfSize;
    int sub;
};

struct HitPoint {
    bool hit;
    vec3 color;
};

layout(std430, binding=4) readonly buffer Octree_data {
    Node nodes[];
};

layout(rgba32f) uniform image2D img_output;

layout(location=2) uniform vec3 start_position;

layout(location=3) uniform vec2 camera_angles;

layout(location=4) uniform vec2 window_size;

layout(location=5) uniform ivec3 front_voxel;

layout(location=6) uniform ivec3 debug_voxel;

bool nodeIsLeaf(in Node node) {
    return node.color.a != -1.0f;
}

ivec3 getSubVector(in ivec3 vec, in Node node) {
    ivec3 subVector = ivec3(0, 0, 0);

    const ivec3 pos = node.position.xyz;
    if (vec.x < pos.x) return ivec3(-1, -1, -1);
    if (vec.y < pos.y) return ivec3(-1, -1, -1);
    if (vec.z < pos.z) return ivec3(-1, -1, -1);

    const int halfSize = node.halfSize;
    const int size = halfSize * 2;
    if (vec.x > pos.x + size) return ivec3(-1, -1, -1);
    if (vec.y > pos.y + size) return ivec3(-1, -1, -1);
    if (vec.z > pos.z + size) return ivec3(-1, -1, -1);

    subVector.x = vec.x >= pos.x + halfSize? 1 : 0;
    subVector.y = vec.y >= pos.y + halfSize? 1 : 0;
    subVector.z = vec.z >= pos.z + halfSize? 1 : 0;

    return subVector;
}

int getSubIndex(in ivec3 vec, in Node node) {
    int subIndex = 0;

    const ivec3 pos = node.position.xyz;
    if (vec.x < pos.x) return -1;
    if (vec.y < pos.y) return -2;
    if (vec.z < pos.z) return -3;

    const int halfSize = node.halfSize;
    const int size = halfSize * 2;
    if (vec.x > pos.x + size) return -4;
    if (vec.y > pos.y + size) return -5;
    if (vec.z > pos.z + size) return -6;

    subIndex |= vec.x >= pos.x + halfSize ? 2 : 0;
    subIndex |= vec.y >= pos.y + halfSize ? 4 : 0;
    subIndex |= vec.z >= pos.z + halfSize ? 1 : 0;

    return subIndex;
}

bool findVoxel(in ivec3 voxelPos, out vec3 color) {
    int index = 0;
    while (index != -1) {
        const Node currentNode = nodes[index];
        if (currentNode.sub == -1) {
            if (currentNode.color.a != -1.0f) {
                color = currentNode.color.rgb;
                return true;
            }
            return false;
        }

        const int subIndex = getSubIndex(voxelPos, currentNode);
        if (subIndex < 0) return false;

        index = currentNode.sub + subIndex;
    }
    return false;
}

vec4 debugCast(vec3 s_pos, in vec3 rayDirection) {
    vec3 color = vec3(0);

    const vec3 rayStepSize = abs(1.0f / rayDirection);
    const ivec3 step = ivec3(sign(rayDirection));
    ivec3 voxelPos = ivec3(s_pos);
    vec3 rayLength = (step * (voxelPos - s_pos) + (step * 0.5f) + 0.5f) * rayStepSize;

    const int maxSize = nodes[0].halfSize * 2;
    bvec3 mask;
    int iter = 0;
    while (iter++ < 400) {
        mask = lessThanEqual(rayLength.xyz, min(rayLength.yzx, rayLength.zxy));
        rayLength += vec3(mask) * rayStepSize;
        voxelPos += ivec3(vec3(mask)) * step;

        if (findVoxel(voxelPos, color)) return vec4(color, 1.0f);
    }
    return vec4(color, 1.0f);
}

int getSubIndexFromSubVector(in const ivec3 vec) {
    if (min(vec.x, min(vec.y, vec.z)) < 0 || max(vec.x, max(vec.y, vec.z)) > 1) return -1;

    int subIndex = 0;
    subIndex |= (vec.x >= 1 ? 2 : 0);
    subIndex |= (vec.y >= 1 ? 4 : 0);
    subIndex |= (vec.z >= 1 ? 1 : 0);
    return subIndex;
}

Layer calculateLayer(inout Layer layer, in const ivec3 dir, in const vec3 rayStepSizeSingle, in const int halfSize) {
    ivec3 vecc = ivec3(layer.position) / halfSize;
    if (min(vecc.x, min(vecc.y, vecc.z)) < -1 || max(vecc.x, max(vecc.y, vecc.z)) > 2) {
        layer.subVec = ivec3(-1, -1, -1);
    } else {
        layer.subVec = clamp(vecc, 0, 1);
    }

    layer.rayLength = (vec3(layer.subVec + dir) * float(halfSize) - layer.position) * rayStepSizeSingle;
    layer.distance = 0.0f;
    return layer;
}

void moveLayer(inout Layer currentLayer, in const ivec3 step, in const vec3 rayStepSize) {
    const vec3 mask = vec3(lessThanEqual(currentLayer.rayLength.xyz, min(currentLayer.rayLength.yzx, currentLayer.rayLength.zxy)).xyz);
    currentLayer.distance = length(mask * currentLayer.rayLength);
    currentLayer.rayLength += mask * rayStepSize;
    currentLayer.subVec += ivec3(mask) * step;
}

vec4 castRay(in vec3 rayDirection) {
    const vec3 rayStepSizeSingle = 1.0f / rayDirection;
    const ivec3 step = ivec3(sign(rayDirection));
    const ivec3 dir = max(step, 0);

    int currentDepth = maxDepth - 1;
    Layer currentLayer;
    Node currentNode = nodes[0];
    currentLayer.nodeIndex = 0;
    currentLayer.position = start_position;

    int halfSize = currentNode.halfSize;
    vec3 rayStepSize = vec3(halfSize) * abs(rayStepSizeSingle);

    Layer layers[] = batchs[localID].layers;
    layers[currentDepth] = calculateLayer(currentLayer, dir, rayStepSizeSingle, halfSize);

    int iter = 0;
    while (iter++ < 500) {
        currentLayer = layers[currentDepth];
        currentNode = nodes[currentLayer.nodeIndex];

        const int subIndex = getSubIndexFromSubVector(currentLayer.subVec);
        if (subIndex < 0) {
            if (++currentDepth == maxDepth) return vec4(0, 0, 0, 0);

            rayStepSize *= 2;
            halfSize *= 2;
        } else if (currentNode.sub != -1) { // If sub == -1 node has't subNodes
            const int subNodexIndex = currentNode.sub + subIndex;
            currentNode = nodes[subNodexIndex];

            if (currentNode.color.a != -1.0f) {
                if (front_voxel == ivec3(currentNode.position)) {
                    return vec4(1, 1, 0, 1);
                }
                return currentNode.color; //vec4(10.0f / iter, 10.0f / iter, 10.0f / iter, 1.0f);
            }

            if (currentDepth != 0) { // If currentDepth == 0 this node empty and have voxel neighbour
                // Start subRaycast
                Layer newLayer;

                rayStepSize /= 2;

                newLayer.nodeIndex = subNodexIndex;
                newLayer.position = currentLayer.position + currentLayer.distance * rayDirection - vec3(halfSize * currentLayer.subVec);

                halfSize /= 2;

                layers[--currentDepth] = calculateLayer(newLayer, dir, rayStepSizeSingle, halfSize);
                continue;
            }
        }
        moveLayer(layers[currentDepth], step, rayStepSize);
    }
    return vec4(0, 0, 0, 0);
}

bool getNode(in ivec3 voxelPos, in int nodeDepth, out Node node) {
    int index = 0;
    int depth = 0;
    while (index != -1) {
        const Node currentNode = nodes[index];
        if (depth == nodeDepth) {
            node = nodes[index];
            return true;
        }

        const int subIndex = getSubIndex(voxelPos, currentNode);
        if (subIndex < 0) return false;

        index = currentNode.sub + subIndex;
        depth++;
    }

    return false;
}

vec3 insideCubeHit(
    const vec3 localRayPosition,
    const vec3 rayDirection,
    const vec3 rayStepSizeSingle,
    float size
) {
    size *= 0.5;

    return -(sign(rayDirection) * (localRayPosition - size) - size) * rayStepSizeSingle;
}

vec4 castRayTest(in vec3 rayDirection, in vec3 rayStartPosition) {
    const vec3 rayStepSizeSingle = 1.0 / max(abs(rayDirection), 0.001);

    float size = nodes[0].halfSize * 2;

    vec3 localRayPosition = mod(rayStartPosition, size);
    vec3 voxelRayPosition = rayStartPosition - localRayPosition;

    vec3 mask;
    bool exitOctree = false;
    int depth = 0;
    float distance = 0.0;

    int iterations = 0;
    for (iterations = 0; iterations < 500; iterations++) {
        if (distance > 1000) break;

        if (exitOctree) {
            size *= 2.0;
            vec3 newVoxelRayPosition = floor(voxelRayPosition / size) * size;

            localRayPosition += voxelRayPosition - newVoxelRayPosition;
            voxelRayPosition = newVoxelRayPosition;

            depth--;

            exitOctree = (depth > 0) &&
                abs(
                    dot(
                        mod(voxelRayPosition / size + 0.5f, 2.0)
                        - 1.0f + mask * sign(rayDirection) * 0.5f,
                        mask
                    )
                ) < 0.1f;
            continue;
        }

        bool skip = false;
        Node node;
        if (!getNode(ivec3(voxelRayPosition), depth, node)) {
            return vec4(0, 0, 0, 0);
        }

        if (node.color.a != -1.0f) {
            return node.color;
        }

        if (node.sub != -1 && depth > maxDepth) {
            skip = true;
        }

        if (node.sub != -1 && depth <= maxDepth) {
            depth++;
            size *= 0.5;

            vec3 mask2 = step(vec3(size), localRayPosition) * size;
            voxelRayPosition += mask2;
            localRayPosition -= mask2;
        } else if (node.sub == -1 || skip) {
            vec3 hit = insideCubeHit(localRayPosition, rayDirection, rayStepSizeSingle, size);

            mask = vec3(
                lessThan(
                    hit,
                    min(
                        vec3(hit.y, hit.z, hit.x),
                        vec3(hit.z, hit.x, hit.y)
                    )
                )
            );
            float len = dot(hit, mask);

            distance += len;
            localRayPosition += rayDirection * len - mask * sign(rayDirection) * size;

            vec3 newVoxelRayPosition = voxelRayPosition + mask * sign(rayDirection) * size;
            exitOctree = (floor(newVoxelRayPosition / size * 0.5f) != floor(voxelRayPosition / size * 0.5f))
            && (depth > 0);

            voxelRayPosition = newVoxelRayPosition;
        }
    }

    return vec4(0, 0, 0, 0);
}


vec4 castWorld(in vec3 rayDirection) {
    const float octreeSize = nodes[0].halfSize * 2.0;
    const ivec3 step = ivec3(sign(rayDirection));

    const vec3 rayStepSizeSingle = 1.0f / max(abs(rayDirection), 0.001f);
    const vec3 rayStepSize = rayStepSizeSingle * octreeSize;

    ivec3 voxelPos = ivec3(start_position / octreeSize);
    if (start_position.x < 0) {
        voxelPos.x--;
    }
    
    if (start_position.y < 0) {
        voxelPos.y--;
    }
    
    if (start_position.z < 0) {
        voxelPos.z--;
    }
    
    const float halfOctreeSize = octreeSize / 2.0f;
    vec3 rayLength = -(sign(rayDirection) * (mod(start_position, octreeSize) - halfOctreeSize) - halfOctreeSize) * rayStepSizeSingle;

    bvec3 mask;

    float distance = 0.0f;
    for (int iterations = 0; iterations < 200; iterations++) {
        if (voxelPos == ivec3(0)) {
            return castRayTest(rayDirection, start_position + rayDirection * distance);
        }

        mask = lessThanEqual(rayLength.xyz, min(rayLength.yzx, rayLength.zxy));

        rayLength += vec3(mask) * rayStepSize;
        distance = length(vec3(mask) * (rayLength - rayStepSize));
        voxelPos += ivec3(vec3(mask)) * step;
    }

    return vec4(0, 0, 0, 0);
}

void rotate(inout vec3 v, const in vec3 axis, float theta) {
    const float cos_theta = cos(theta);
    v = (v * cos_theta) + (cross(axis, v) * sin(theta)) + (axis * dot(axis, v)) * (1 - cos_theta);
}

void main() {
    /*
        TODO CHECK OPTIMIZATION
        vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;
        vec3 rayDirection = normalize(vec3(uv, 1.0));
    */

    const ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.xy);
    const ivec3 screen_coord = ivec3(pixel_coord - window_size / 2, -window_size.x);

    vec3 rayDir = normalize(screen_coord);
    rotate(rayDir, vec3(1, 0, 0), camera_angles.y);
    rotate(rayDir, vec3(0, 1, 0), camera_angles.x);

    imageStore(img_output, pixel_coord, castWorld(rayDir));
}